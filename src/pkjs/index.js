var VERSION = "1.3.0";
var Clay = require('pebble-clay');
var clayConfig = require('./config.json');
var clay = new Clay(clayConfig, null, { autoHandleEvents: false });
const API = {
  BASE_URL: "https://api-eu.libreview.io",
  PRODUCT: "llu.android",
  VERSION: "4.16.0"
};
var testCredentials = {};

var isReady = false;
var callbacks = [];

// Hardcoded default settings used when Clay has no stored values
var DEFAULT_SETTINGS = {
  invert: 0,        // 0 = normal, 1 = inverted
  textAlign: 1,     // 1 = left
  language: 3       // 3 = EN_US (see package.json messageKeys)
};

// Message keys generated by Pebble SDK (see package.json messageKeys)
var KEYS = require('message_keys');

function onReady(callback) {
  if (isReady) {
    callback();
    return;
  }
  callbacks.push(callback);
}

function logError(err) {
  console.log('AppMessage error: ' + JSON.stringify(err));
}

// Store latest glucose data
var glucoseData = {
  value: 0,
  trend: -1,
  timestamp: 0
};

// Cache configuration
var CACHE_KEY = 'glucose_cache';
var CACHE_MAX_AGE_MS = 5 * 60 * 1000; // 10 minutes - glucose updates every 15 min

// Glucose cache functions
function getCachedGlucose() {
  try {
    var cached = localStorage.getItem(CACHE_KEY);
    if (!cached) {
      console.log('No cached glucose data found');
      return null;
    }
    
    var data = JSON.parse(cached);
    var age = Date.now() - data.cachedAt;
    
    if (age > CACHE_MAX_AGE_MS) {
      console.log('Cached glucose data expired (age: ' + Math.round(age / 1000) + 's)');
      return null;
    }
    
    console.log('Using cached glucose data (age: ' + Math.round(age / 1000) + 's)');
    return data;
  } catch (e) {
    console.log('Error reading glucose cache: ' + e.message);
    return null;
  }
}

function setCachedGlucose(value, trend, timestamp) {
  try {
    var data = {
      value: value,
      trend: trend,
      timestamp: timestamp,
      cachedAt: Date.now()
    };
    localStorage.setItem(CACHE_KEY, JSON.stringify(data));
    console.log('Glucose data cached');
  } catch (e) {
    console.log('Error caching glucose data: ' + e.message);
  }
}

function clearGlucoseCache() {
  try {
    localStorage.removeItem(CACHE_KEY);
    console.log('Glucose cache cleared');
  } catch (e) {
    console.log('Error clearing glucose cache: ' + e.message);
  }
}

// Main function to get glucose data - uses cache when available
// forceRefresh: if true, bypasses cache and fetches fresh data from API
// credentials: optional {email, password} - if provided, uses these instead of getCredentials()
function getGlucoseData(forceRefresh, credentials) {
  // Check cache first (unless force refresh)
  if (!forceRefresh) {
    var cached = getCachedGlucose();
    if (cached) {
      console.log('Returning cached glucose: ' + cached.value + ' mg/dL');
      return Promise.resolve({ value: cached.value, trend: cached.trend, ts: cached.timestamp });
    }
  }
  
  // Get credentials - use provided ones or fetch from storage
  var creds;
  if (credentials && credentials.email && credentials.password) {
    creds = credentials;
    console.log('getGlucoseData: using provided credentials');
  } else {
    creds = getCredentials();
  }
  
  // Fetch fresh data from API
  return fetchGlucoseFromLibreLinkUp(creds.email, creds.password);
}

// SHA256 für Account-Id (pure JS implementation)
function sha256Hex(str) {
  function rightRotate(value, amount) {
    return (value >>> amount) | (value << (32 - amount));
  }

  var mathPow = Math.pow;
  var maxWord = mathPow(2, 32);
  var lengthProperty = 'length';
  var i, j;
  var result = '';

  var words = [];
  var asciiBitLength = str[lengthProperty] * 8;

  var hash = [];
  var k = [];
  var primeCounter = 0;

  var isComposite = {};
  for (var candidate = 2; primeCounter < 64; candidate++) {
    if (!isComposite[candidate]) {
      for (i = 0; i < 313; i += candidate) {
        isComposite[i] = candidate;
      }
      hash[primeCounter] = (mathPow(candidate, 0.5) * maxWord) | 0;
      k[primeCounter++] = (mathPow(candidate, 1 / 3) * maxWord) | 0;
    }
  }

  str += '\x80';
  while ((str[lengthProperty] % 64) - 56) str += '\x00';
  for (i = 0; i < str[lengthProperty]; i++) {
    j = str.charCodeAt(i);
    if (j >> 8) return;
    words[i >> 2] |= j << (((3 - i) % 4) * 8);
  }
  words[words[lengthProperty]] = (asciiBitLength / maxWord) | 0;
  words[words[lengthProperty]] = asciiBitLength;

  for (j = 0; j < words[lengthProperty]; ) {
    var w = words.slice(j, (j += 16));
    var oldHash = hash;
    hash = hash.slice(0, 8);

    for (i = 0; i < 64; i++) {
      var w15 = w[i - 15], w2 = w[i - 2];
      var a = hash[0], e = hash[4];
      var temp1 =
        hash[7] +
        (rightRotate(e, 6) ^ rightRotate(e, 11) ^ rightRotate(e, 25)) +
        ((e & hash[5]) ^ (~e & hash[6])) +
        k[i] +
        (w[i] =
          i < 16
            ? w[i]
            : (w[i - 16] +
                (rightRotate(w15, 7) ^ rightRotate(w15, 18) ^ (w15 >>> 3)) +
                w[i - 7] +
                (rightRotate(w2, 17) ^ rightRotate(w2, 19) ^ (w2 >>> 10))) |
              0);
      var temp2 =
        (rightRotate(a, 2) ^ rightRotate(a, 13) ^ rightRotate(a, 22)) +
        ((a & hash[1]) ^ (a & hash[2]) ^ (hash[1] & hash[2]));

      hash = [(temp1 + temp2) | 0].concat(hash);
      hash[4] = (hash[4] + temp1) | 0;
    }

    for (i = 0; i < 8; i++) {
      hash[i] = (hash[i] + oldHash[i]) | 0;
    }
  }

  for (i = 0; i < 8; i++) {
    for (j = 3; j + 1; j--) {
      var b = (hash[i] >> (j * 8)) & 255;
      result += (b < 16 ? '0' : '') + b.toString(16);
    }
  }
  return result;
}

function readyCallback(event) {
  isReady = true;
  console.log("Pebble JS ready");
  while (callbacks.length > 0) {
    var callback = callbacks.shift();
    callback(event);
  }
}

function showConfiguration(event) {
  console.log('Configuration page requested (Clay)');
  Pebble.openURL(clay.generateUrl());
}

function webviewclosed(event) {
  if (!event || !event.response || event.response === 'CANCELLED') {
    console.log('Configuration cancelled or empty');
    return;
  }

  try {
    // Use convert=false to get raw settings with readable keys
    var rawSettings = clay.getSettings(event.response, false);
    console.log('Clay raw settings: ' + JSON.stringify(rawSettings));
    console.log('Clay email type: ' + typeof rawSettings.email + ', value: ' + JSON.stringify(rawSettings.email));
    console.log('Clay password type: ' + typeof rawSettings.password + ', value: ' + (rawSettings.password ? '***' : 'undefined'));

    localStorage.setItem('options', JSON.stringify(rawSettings));
    console.log('Stored options to localStorage');

    // Extract credentials directly from rawSettings (handle both direct and wrapped values)
    var email = rawSettings.email;
    if (email && typeof email === 'object') {
      email = email.value;
    }
    var password = rawSettings.password;
    if (password && typeof password === 'object') {
      password = password.value;
    }
    console.log('Extracted credentials - email: ' + (email ? email.substring(0, 3) + '***' : 'undefined'));

    // Clear cache when settings change (credentials may have changed)
    clearGlucoseCache();

    // Build message using the normalized helper so defaults are applied when missing
    var message = prepareConfiguration(rawSettings);
    console.log('Sending message to watch: ' + JSON.stringify(message));
    sendSettingsToWatch(message);

    // Fetch fresh glucose data with new settings (pass credentials directly)
    getGlucoseData(true, { email: email, password: password }).then(function(data) {
      if (data) {
        updateGlucoseData(data.value, data.trend, data.ts);
      } else {
        console.log('No glucose data fetched after settings save');
      }
    }).catch(function(err) {
      console.log('Error fetching glucose after settings save: ' + err.message);
    });
  } catch (e) {
    console.log('Error parsing configuration: ' + e.message + ' - ' + e.stack);
  }
}

function sendSettingsToWatch(message) {
  if (!isReady) {
    callbacks.push(function() { sendSettingsToWatch(message); });
    return;
  }

  Pebble.sendAppMessage(message, function() {
    console.log('Settings delivered to watch: ' + JSON.stringify(message));
  }, function(err) {
    console.log('Error sending settings: ' + JSON.stringify(err));
  });
}

function getOptions() {
  return localStorage.getItem("options") || "{}";
}

function parseOptions() {
  try {
    var raw = getOptions();
    console.log('parseOptions raw: ' + raw);
    var parsed = JSON.parse(raw);
    console.log('parseOptions parsed keys: ' + Object.keys(parsed).join(', '));
    return parsed;
  } catch (e) {
    console.log('Error parsing stored options, using defaults: ' + e.message);
    return {};
  }
}

// Unified credential retrieval - single source of truth
function getCredentials() {
  var options = parseOptions();
  
  // Clay may store values directly or wrapped in {value: ...} objects
  var email = options.email;
  if (email && typeof email === 'object') {
    email = email.value;
  }
  
  var password = options.password;
  if (password && typeof password === 'object') {
    password = password.value;
  }
  
  console.log('getCredentials: email=' + (email ? email.substring(0, 3) + '***' : 'undefined') + ', password=' + (password ? '***' : 'undefined'));
  
  // Fallback to test credentials if not configured
  if (!email && testCredentials.email) {
    email = testCredentials.email;
  }
  if (!password && testCredentials.password) {
    password = testCredentials.password;
  }
  
  return { email: email, password: password };
}

// Normalize Clay settings, applying defaults when no value was provided
function getSettingsWithDefaults(options) {
  var opts = options || parseOptions();

  // Support both Clay raw keys (INVERT_KEY) and earlier flattened keys (INVERT)
  var invert = (typeof opts.INVERT_KEY !== 'undefined') ? opts.INVERT_KEY : opts.INVERT;
  if (invert && typeof invert === 'object') {
    invert = invert.value;
  }

  var align = (typeof opts.TEXT_ALIGN_KEY !== 'undefined') ? opts.TEXT_ALIGN_KEY : opts.TEXT_ALIGN;
  if (align && typeof align === 'object') {
    align = align.value;
  }

  var language = (typeof opts.LANGUAGE_KEY !== 'undefined') ? opts.LANGUAGE_KEY : opts.LANGUAGE;
  if (language && typeof language === 'object') {
    language = language.value;
  }

  return {
    INVERT: (typeof invert !== 'undefined') ? invert : DEFAULT_SETTINGS.invert,
    TEXT_ALIGN: (typeof align !== 'undefined') ? parseInt(align, 10) : DEFAULT_SETTINGS.textAlign,
    LANGUAGE: (typeof language !== 'undefined') ? parseInt(language, 10) : DEFAULT_SETTINGS.language
  };
}

function prepareConfiguration(optionsJson) {
  var options = typeof optionsJson === 'string' ? JSON.parse(optionsJson) : optionsJson;
  var settings = getSettingsWithDefaults(options);

  var message = {};
  message[KEYS.INVERT_KEY] = settings.INVERT ? 1 : 0;
  message[KEYS.TEXT_ALIGN_KEY] = settings.TEXT_ALIGN;
  message[KEYS.LANGUAGE_KEY] = settings.LANGUAGE;

  return message;
}

function appmessage(event) {
  console.log('Received message from watch');
  var payload = event.payload;

  if (payload && payload[KEYS.KEY_REQUEST_DATA]) {
    console.log('Watch requested glucose data');
    // Use cache when available (no force refresh - this is the main use case for caching)
    getGlucoseData(false).then(function(data) {
      if (data) {
        updateGlucoseData(data.value, data.trend, data.ts);
      } else {
        console.log('No glucose data fetched');
      }
    }).catch(function(err) {
      console.log('Error fetching glucose: ' + err.message);
    });
  }
}

function transmitConfiguration(settings) {
  console.log('Sending configuration: ' + JSON.stringify(settings));
  Pebble.sendAppMessage(settings, function(event) {
    console.log('Configuration delivered successfully');
  }, logError);
}

function sendGlucoseData() {
  if (glucoseData.value <= 0) {
    console.log('No glucose data to send');
    return;
  }

  var message = {};
  message[KEYS.KEY_GLUCOSE_VALUE] = glucoseData.value;
  message[KEYS.KEY_TREND_VALUE] = glucoseData.trend;
  message[KEYS.KEY_TIMESTAMP] = glucoseData.timestamp;

  console.log('Sending glucose data: ' + JSON.stringify(message));
  Pebble.sendAppMessage(message, function(event) {
    console.log('Glucose data delivered');
  }, logError);
}

function updateGlucoseData(value, trend, timestamp) {
  glucoseData.value = value || 0;
  glucoseData.trend = (typeof trend !== 'undefined') ? trend : -1;
  glucoseData.timestamp = timestamp || Math.floor(Date.now() / 1000);
  console.log('Glucose updated: ' + glucoseData.value + ' mg/dL, trend: ' + glucoseData.trend);

  // Cache the glucose data
  setCachedGlucose(glucoseData.value, glucoseData.trend, glucoseData.timestamp);

  onReady(function() {
    sendGlucoseData();
  });
}

Pebble.updateGlucose = updateGlucoseData;

// Hilfsfunktion: letzte Messung
function pickMeasurement(container) {
  if (!container) {
    console.log("pickMeasurement: container is null");
    return null;
  }

  console.log("pickMeasurement: container keys = " + Object.keys(container).join(", "));

  // Try to get measurement from various possible locations
  var m = container.glucoseMeasurement || container.glucoseItem;
  
  if (m) {
    console.log("pickMeasurement: found glucoseMeasurement/glucoseItem");
    // Check if it has measurementData array
    if (m.measurementData && Array.isArray(m.measurementData) && m.measurementData.length > 0) {
      console.log("pickMeasurement: using measurementData array, length=" + m.measurementData.length);
      return m.measurementData[m.measurementData.length - 1];
    }
    // Otherwise return the measurement object itself
    return m;
  }
  
  // If no glucoseMeasurement/glucoseItem, the container might be the measurement itself
  if (container.ValueInMgPerDl || container.Value) {
    console.log("pickMeasurement: container is the measurement itself");
    return container;
  }
  
  console.log("pickMeasurement: no measurement found in container");
  return null;
}
// Fetch Glucose
function fetchGlucoseFromLibreLinkUp(email, password) {
  if (!email || !password) {
    console.log("Credentials fehlen");
    return Promise.resolve(null);
  }

  console.log("Starte LibreLinkUp Login...");
  console.log("Email: " + email.substring(0, 3) + "***");

  // Always use DE region
  var baseUrl = "https://api-de.libreview.io";
  var token, accountId, authHeaders;

  var loginHeaders = {
    "Content-Type": "application/json",
    "product": API.PRODUCT,
    "version": API.VERSION
  };

  // Helper function for XHR requests
  function xhrRequest(url, method, headers, body) {
    return new Promise(function(resolve, reject) {
      var xhr = new XMLHttpRequest();
      xhr.open(method, url, true);
      
      for (var key in headers) {
        if (headers.hasOwnProperty(key)) {
          xhr.setRequestHeader(key, headers[key]);
        }
      }
      
      xhr.onload = function() {
        console.log("XHR response: " + xhr.status + " from " + url);
        if (xhr.status >= 200 && xhr.status < 300) {
          try {
            var json = JSON.parse(xhr.responseText);
            resolve({ status: xhr.status, ok: true, json: json });
          } catch (e) {
            console.log("JSON parse error: " + e.message);
            reject(new Error("JSON parse error"));
          }
        } else {
          console.log("XHR error status: " + xhr.status);
          reject(new Error("HTTP " + xhr.status));
        }
      };
      
      xhr.onerror = function() {
        console.log("XHR network error");
        reject(new Error("Network error"));
      };
      
      xhr.ontimeout = function() {
        console.log("XHR timeout");
        reject(new Error("Timeout"));
      };
      
      xhr.timeout = 30000;
      
      if (body) {
        xhr.send(body);
      } else {
        xhr.send();
      }
    });
  }

  // 1️⃣ Login
  return xhrRequest(baseUrl + "/llu/auth/login", "POST", loginHeaders, JSON.stringify({ email: email, password: password }))
    .then(function(result) {
      var loginJson = result.json;

      console.log("Processing login result, status: " + loginJson.status);
      if (loginJson.status !== 0) {
        console.log("Login failed: json.status=" + loginJson.status);
        throw new Error("Login fehlgeschlagen");
      }

      token = loginJson.data && loginJson.data.authTicket && loginJson.data.authTicket.token;
      var userId = loginJson.data && loginJson.data.user && loginJson.data.user.id;
      console.log("Token present: " + !!token + ", userId present: " + !!userId);
      if (!token || !userId) {
        throw new Error("Token oder User ID fehlt");
      }

      accountId = sha256Hex(userId);
      console.log("AccountId generated, fetching connections...");

      // 2️⃣ Connections abrufen
      authHeaders = {
        "Content-Type": "application/json",
        "product": API.PRODUCT,
        "version": API.VERSION,
        "Authorization": "Bearer " + token,
        "Account-Id": accountId
      };

      return xhrRequest(baseUrl + "/llu/connections", "GET", authHeaders, null);
    })
    .then(function(result) {
      var connJson = result.json;
      console.log("Connections response status: " + connJson.status);
      if (!connJson.data || !connJson.data.length) {
        throw new Error("Keine Connections gefunden");
      }

      var connection = connJson.data[0];
      console.log("Connection found, patientId: " + connection.patientId);

      // 3️⃣ Letzte Messung auslesen
      var measurement = pickMeasurement(connection);

      // Wenn keine Messung vorhanden, Graph abfragen
      if (!measurement || (!measurement.ValueInMgPerDl && !measurement.Value)) {
        console.log("No direct measurement, fetching graph...");
        var patientId = connection.patientId;
        return xhrRequest(baseUrl + "/llu/connections/" + patientId + "/graph", "GET", authHeaders, null)
          .then(function(graphResult) {
            console.log("Graph response received");
            var connGraph = graphResult.json.data && graphResult.json.data.connection;
            return pickMeasurement(connGraph);
          });
      }

      return measurement;
    })
    .then(function(measurement) {
      if (!measurement) {
        throw new Error("Keine Messung gefunden");
      }

      var value = measurement.ValueInMgPerDl || measurement.Value;
      var trend = measurement.TrendArrow !== undefined ? measurement.TrendArrow : (measurement.Trend !== undefined ? measurement.Trend : -1);
      var tsString = measurement.Timestamp || measurement.FactoryTimestamp;
      var ts = tsString ? Math.floor(new Date(tsString).getTime() / 1000) : Math.floor(Date.now() / 1000);

      console.log("Measurement extracted: value=" + value + ", trend=" + trend);
      return { value: value, trend: trend, ts: ts };
    })
    .catch(function(err) {
      console.log("Fetch fehlgeschlagen: " + err.message);
      return null;
    });
}

function logError(event) {
  console.log('Unable to deliver message with transactionId=' +
              event.data.transactionId + '; Error: ' + JSON.stringify(event.error));
}

// Register event listeners
Pebble.addEventListener("ready", readyCallback);
Pebble.addEventListener("showConfiguration", showConfiguration);
Pebble.addEventListener("webviewclosed", webviewclosed);
Pebble.addEventListener("appmessage", appmessage);

// Automatic glucose refresh interval (5 minutes in milliseconds)
var GLUCOSE_REFRESH_INTERVAL_MS = 5 * 60 * 1000;
var glucoseRefreshTimer = null;

// Function to fetch and send glucose data proactively
function refreshGlucoseData() {
  console.log('Auto-refresh: fetching glucose data');
  // Force refresh to get latest data from API (not cache)
  getGlucoseData(true).then(function(data) {
    if (data) {
      updateGlucoseData(data.value, data.trend, data.ts);
      console.log('Auto-refresh: glucose data sent to watch');
    } else {
      console.log('Auto-refresh: no glucose data available');
    }
  }).catch(function(err) {
    console.log('Auto-refresh error: ' + err.message);
  });
}

// Start the automatic glucose refresh timer
function startGlucoseRefreshTimer() {
  if (glucoseRefreshTimer) {
    clearInterval(glucoseRefreshTimer);
  }
  glucoseRefreshTimer = setInterval(refreshGlucoseData, GLUCOSE_REFRESH_INTERVAL_MS);
  console.log('Glucose refresh timer started (interval: ' + (GLUCOSE_REFRESH_INTERVAL_MS / 1000) + 's)');
}

// Send initial configuration on ready
onReady(function(event) {
  var message = prepareConfiguration(getOptions());
  transmitConfiguration(message);
  
  // Use cache on startup for faster loading
  getGlucoseData(false).then(function(data) {
    if (data) {
      updateGlucoseData(data.value, data.trend, data.ts);
    } else {
      console.log('No glucose data fetched at startup');
    }
  }).catch(function(err) {
    console.log('Error fetching glucose at startup: ' + err.message);
  });
  
  // Start automatic glucose refresh timer
  // This ensures the watch always gets updated data even if it doesn't request it
  startGlucoseRefreshTimer();
});

